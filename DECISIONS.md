# DECISIONS.md

## 1. Overview and Initial Approach

This was my first time building a full Django + DRF backend and connecting it to a React frontend. My initial approach was to break the assignment into two parts:
1) understand the backend requirements and implement the API,
2) build a simple, clear frontend that consumes the API.

Since I did not have prior experience with Django, DRF, serializers, model validation, or ViewSets, I started by reviewing official documentation and using AI tools to explain concepts in simpler terms. I validated any AI-generated code by testing it locally, adapting it, and making sure I understood what each part was doing. I kept notes about what I learned and why I made certain decisions so I could explain the reasoning clearly.

I originally tried using Next.js (via the v0 Vercel template), but I later switched to React + Vite because the structure generated by Lovable AI was cleaner, simpler, and easier to modify for a dashboard-style interface. The switch also reduced complexity in development and debugging.

## 2. Architectural Decisions and Why I Chose This Approach

### Backend: Django + DRF

The assignment required Django + DRF, which helped guide the architecture. My reasoning:

- Django models give a clear representation of my data and act like schemas.
- DRF serializers simplify converting model instances to JSON and validating input.
- A ViewSet fits the assignment well because it supports CRUD operations and reduces repetitive code.

Using these together gave me structure and helped me keep concerns separated:
- models contain the data rules
- serializers handle API validation
- viewsets handle request routing and logic

I wanted all core business logic (like renewal date calculations) to live in the model so it applies universally, no matter where the data comes from.

### Frontend: React + Vite

React + Vite offered faster iteration and a simpler file structure than Next.js for this task. The dashboard is client-heavy, and I did not need routing or SSR features. Vite provided fast rebuilds which helped while testing API interactions.

## 3. Data Model Structure and Reasoning

I designed one main model: Subscription, with fields for name, cost, billing cycle, start date, renewal date, category, and an is_active flag.

I included:
- is_active instead of deleting entries because the assignment mentions canceling subscriptions without losing history
- a category field to support future filtering and analytics
- renewal_date stored in the database instead of calculated on every request

### Auto-Renewal Logic

I implemented calculate_next_renewal() inside the model. My reasoning was that this logic is central to the business domain, and by placing it inside the model, it remains consistent whether subscriptions are created from the admin panel, API, or scripts.

### Validation

I implemented field-level validators (for example: cost must be positive, billing_cycle must be monthly or yearly). I kept object-level validation simple and relied on the model logic for renewal date calculation.

## 4. API Design Choices and RESTful Patterns

I used a DRF ModelViewSet so I did not have to write separate view functions for create, list, update, delete, and retrieve. This matched the required user stories and reduced boilerplate code.

The ViewSet automatically exposes:
- GET /api/subscriptions/
- POST /api/subscriptions/
- GET /api/subscriptions/{id}/
- PATCH/PUT /api/subscriptions/{id}/
- DELETE /api/subscriptions/{id}/

The queryset filters subscriptions by is_active=True so only active subscriptions appear in lists.

The perform_destroy method sets is_active=False instead of deleting the object, which implements the idea of canceling a subscription without losing history.

### Stats Endpoint

I implemented a custom route at /api/subscriptions/stats/ using @action(detail=False). This endpoint calculates:
- total monthly equivalent cost
- total yearly equivalent cost
- subscriptions renewing within the next 7 days
- a list of upcoming renewals

Django annotations (Case, When, F) allowed me to perform these calculations at the database level.

## 5. Iterations, Debugging Process, and Problems I Encountered

### CORS Issue

After switching to React + Vite, the browser blocked API requests from Django due to CORS.  
Fix: I installed django-cors-headers and enabled it in settings.py so the frontend could communicate with Django.

### JavaScript Cost Parsing Bug (Frontend)

Django's DecimalField serializes numbers as strings. For example, sub.cost is something like "35.00".  
When I tried to do:

#### sub.cost / 12

the result was NaN.

This broke monthly/yearly cost conversion, the cost breakdown chart, and the savings calculator.

Fix: Convert the cost into a number:

const cost = Number(sub.cost);

After converting, all calculations and the Recharts visualization worked correctly.

### Chart Logic and Savings Calculator

For the savings calculator, I used a simple method: yearly subscriptions should be cheaper by two months worth of cost compared to monthly billing. This was easy to implement and explain.

### React Component Issues with Dialogs (Radix)

I initially used Radix UI for dialogs, but I encountered dependency issues such as the react-dismissable-layer module not resolving. After reinstall attempts and clearing caches, I decided to remove Radix dialogs and implement a simpler UI, which better aligned with the project deadline and kept the focus on the actual functionality.

### Framework Switch

I first built the frontend with Next.js using a v0 template, but the generated structure became difficult to modify. Switching to a React + Vite structure generated by Lovable AI gave me a simpler setup, faster development, and fewer framework issues.

## 6. Design Patterns and Trade-Offs

### Patterns Used

- Separation of concerns between models, serializers, views, and components
- Centralized domain logic inside the model
- Soft delete approach using is_active to cancel subscriptions

### Trade-Offs

- Kept object-level validation minimal
- Did not implement authentication because it was outside requirements
- The frontend focuses on functionality instead of full UI polish

## 7. What I Would Do Differently With More Time

- Add authentication and user accounts
- Improve frontend validation and form error displays
- Add reminder notifications using Celery
- Move categories into a dedicated model
- Add pagination and search
- Add automated backend and frontend tests

## 8. AI Tools Usage and How I Validated the Output

I used AI tools to learn about Django, DRF, and React patterns, and to generate some boilerplate code. To validate any AI-generated code, I:

- read the code manually
- tested the logic in Django shell
- checked API responses
- modified the results to fit the assignment
- All major decisions and debugging were done by me after understanding the suggestions.

## 9. Handling Edge Cases and Errors

- Ensured cost is always positive using field validation
- Ensured billing_cycle is either monthly or yearly
- Renewal date is always auto-calculated into the future
- Canceled subscriptions are excluded from active lists
- API returns DRF validation errors for invalid input
- Frontend converts cost strings to numbers to avoid NaN errors

## Final Note

Throughout this project, I focused on understanding each part of the implementation. I documented my reasoning, challenges, and decisions as clearly as possible, reflecting the learning journey I followed while building this solution.
