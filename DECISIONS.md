# DECISIONS.md

## 1. Overview and Initial Approach

This was my first time building a full Django + DRF backend and connecting it to a React frontend. My initial approach was to break the assignment into two parts:
1) understand the backend requirements and implement the API,
2) build a simple, clear frontend that consumes the API.

Since I did not have prior experience with Django, DRF, serializers, model validation, or ViewSets, I started by reviewing official documentation and using AI tools to explain concepts in simpler terms. I validated any AI-generated code by testing it locally, adapting it, and making sure I understood what each part was doing. I kept notes about what I learned and why I made certain decisions so I could explain the reasoning clearly.

I originally tried using Next.js (via the v0 Vercel template), but I later switched to React + Vite because the structure generated by Lovable AI was cleaner, simpler, and easier to modify for a dashboard-style interface. The switch also reduced complexity in development and debugging.

## 2. Architectural Decisions and Why I Chose This Approach

### Backend: Django + DRF

The assignment required Django + DRF, which helped guide the architecture. My reasoning:

- Django models give a clear representation of my data and act like schemas.
- DRF serializers simplify converting model instances to JSON and validating input.
- A ViewSet fits the assignment well because it supports CRUD operations and reduces repetitive code.

Using these together gave me structure and helped me keep concerns separated:
- models contain the data rules
- serializers handle API validation
- viewsets handle request routing and logic

I wanted all core business logic (like renewal date calculations) to live in the model so it applies universally, no matter where the data comes from.

### Frontend: React + Vite

React + Vite offered faster iteration and a simpler file structure than Next.js for this task. The dashboard is client-heavy, and I did not need routing or SSR features. Vite provided fast rebuilds which helped while testing API interactions.

## 3. Data Model Structure and Reasoning

I designed one main model: Subscription, with fields for name, cost, billing cycle, start date, renewal date, category, and an is_active flag.

I included:
- is_active instead of deleting entries because the assignment mentions canceling subscriptions without losing history
- a category field to support future filtering and analytics
- renewal_date stored in the database instead of calculated on every request

### Auto-Renewal Logic

I implemented calculate_next_renewal() inside the model. My reasoning was that this logic is central to the business domain, and by placing it inside the model, it remains consistent whether subscriptions are created from the admin panel, API, or scripts.

### Validation

I implemented field-level validators (for example: cost must be positive, billing_cycle must be monthly or yearly). I kept object-level validation simple and relied on the model logic for renewal date calculation.

## 4. API Design Choices and RESTful Patterns

I used a DRF ModelViewSet so I did not have to write separate view functions for create, list, update, delete, and retrieve. This matched the required user stories and reduced boilerplate code.

The ViewSet automatically exposes:
- GET /api/subscriptions/
- POST /api/subscriptions/
- GET /api/subscriptions/{id}/
- PATCH/PUT /api/subscriptions/{id}/
- DELETE /api/subscriptions/{id}/

The queryset filters subscriptions by is_active=True so only active subscriptions appear in lists.

The perform_destroy method sets is_active=False instead of deleting the object, which implements the idea of canceling a subscription without losing history.

### Stats Endpoint

I implemented a custom route at /api/subscriptions/stats/ using @action(detail=False). This endpoint calculates:
- total monthly equivalent cost
- total yearly equivalent cost
- subscriptions renewing within the next 7 days
- a list of upcoming renewals

Django annotations (Case, When, F) allowed me to perform these calculations at the database level.

## 5. Iterations, Debugging Process, and Problems I Encountered

### CORS Issue

After switching to React + Vite, the browser blocked API requests from Django due to CORS.  
Fix: I installed django-cors-headers and enabled it in settings.py so the frontend could communicate with Django.

### JavaScript Cost Parsing Bug (Frontend)

Django's DecimalField serializes numbers as strings. For example, sub.cost is something like "35.00".  
When I tried to do:

#### sub.cost / 12
