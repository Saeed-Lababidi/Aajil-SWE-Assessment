# DECISIONS – Subscription Management Dashboard

1. Overview and Initial Approach

This was my first time building a full Django + DRF backend and connecting it to a React frontend. My initial approach was to break the assignment into two parts:

understand the backend requirements and implement the API,

build a simple, clear frontend that consumes the API.

Since I did not have prior experience with Django, DRF, serializers, model validation, or ViewSets, I started by reviewing official documentation and using AI tools to explain concepts in simpler terms. I validated any AI-generated code by testing it locally, adapting it, and making sure I understood what each part was doing. I kept notes about what I learned and why I made certain decisions so I could explain the reasoning clearly.

I originally tried using Next.js (via the v0 Vercel template), but I later switched to React + Vite because the structure generated by Lovable AI was cleaner, simpler, and easier to modify for a dashboard-style interface. The switch also reduced complexity in development and debugging.

2. Architectural Decisions and Why I Chose This Approach
Backend: Django + DRF

The assignment required Django + DRF, which helped guide the architecture. My reasoning:

Django models give a clear representation of my data and act like schemas.

DRF serializers simplify converting model instances to JSON and validating input.

A ViewSet fits perfectly because the assignment asks for standard CRUD + one extra analytics endpoint.

Using these together gave me structure and helped me keep concerns separated:

models → data rules

serializers → API validation

viewsets → endpoints + business operations

I wanted all “core business logic” (like renewal date calculations) to live in the model so it applies universally—whether data comes from the admin panel, API, or elsewhere.

Frontend: React + Vite

React + Vite offered faster iteration and a simpler file structure than Next.js for this task. The dashboard is client-heavy, and I didn’t need routing or SSR features that Next.js provides. Vite also gave very fast rebuild times which helped while debugging and testing API integrations.

3. Data Model Structure and Reasoning

I designed one main model: Subscription, with fields for name, cost, billing cycle, start date, renewal date, category, and an is_active flag.

I included:

is_active instead of deleting entries because the assignment mentions canceling subscriptions without losing history.

A category field because it makes future analytics easier without requiring schema changes.

renewal_date as a database field (instead of calculating it on every request) to improve performance and make filtering easier.

Auto-Renewal Logic

I implemented calculate_next_renewal() inside the model. My reasoning:
This logic is central to the business domain, and placing it in the model ensures consistency from all entry points.

Validation

I implemented field-level validators (e.g., cost must be positive, billing_cycle must be monthly/yearly) and kept object-level validation simple, deliberately relying on the model for renewal calculations. This is acceptable for an entry-level solution because the key logic stays centralized.

4. API Design Choices and RESTful Patterns

I used a DRF ModelViewSet for the Subscription API to avoid writing separate view functions for create, list, update, delete, and retrieve. This matched the required user stories exactly and reduced repetitive code.

The ViewSet automatically exposes:

GET /api/subscriptions/

POST /api/subscriptions/

GET /api/subscriptions/{id}/

PATCH/PUT /api/subscriptions/{id}/

DELETE /api/subscriptions/{id}/

I filtered the queryset to only show is_active=True so the list endpoint reflects active subscriptions, as required.

Instead of actually deleting items, perform_destroy() sets is_active=False to mark subscriptions as canceled. This allows the frontend to display and manage active subscriptions without losing historical data.

Stats Endpoint

I added a custom route /api/subscriptions/stats/ using @action(detail=False). This endpoint calculates:

total monthly equivalent cost

total yearly equivalent cost

subscriptions renewing within 7 days

full list of upcoming renewals

I used Django annotations (CASE, WHEN, F) to perform calculations in the database efficiently. This was one of the lessons I learned while reading the DRF and Django ORM docs.

To be honest I had not worked with Django, Django REST Framework (DRF), or serializers before. So I had to learn on the go.
Because the assignment explicitly requires Django + DRF for the backend, my first step was to learn the basics:
- What a Django project and app are
- How models map to database tables
- What an API is in the context of Django
- What DRF serializers and validation do

To speed up this learning process, I used a combination of:
- AI tools (e.g. ChatGPT) to explain concepts in simpler terms and generate small code snippets
- Search through the documentation on https://docs.djangoproject.com/en/5.2/.
- Trial and error by running the server, checking errors, and fixing them

Whenever I used AI-generated code, I:
1. Read through it to understand what each line was doing.
2. Ask for a deeper explanation for the functions of each file and the purpose of the unique file layouts (especially in django)
3. Tested it locally to verify that it behaved as expected.

## 2. Tech Stack Choices

### Backend: Django + Django REST Framework

Since this was my first time using Django, I had to learn the basic structure of a Django project:

- The project (`config`) contains global settings and URL configuration.
- The `subscriptions` app is a focused module that contains the model, views, and API logic for subscriptions.
- The `Subscription` model defines the schema of the `subscriptions` table in the database (fields like `name`, `cost`, `billing_cycle`, etc.).
- Migrations (`makemigrations` and `migrate`) are used to translate model changes into actual database changes.
- I also registered the `Subscription` model in Django’s admin site so I could easily create and inspect subscription records during development.

Understanding this structure was my first step before adding Django REST Framework and building the actual API.
I also loved the fact that the DRF has built in serializers and validation.

### Database: SQLite

I chose the default SQLite database because:
- It requires no extra setup and works out-of-the-box with Django.
- It is more than enough for a small project.
- If the project needed to scale later, the same Django models could work with other databases with minimal changes.

### Frontend: React

For the frontend, I chose React because:
- The assignment needs charts, lists, and filters, which React can handle with reusable bootstrap components.
- Separates frontend from backend, which matches the idea of a REST API backend.

I chose React because the dashboard requires interactive charts, filtering, real-time state updates, and reusable components. React allows me 
to quickly build a clean, modular UI with libraries like Recharts or Chart.js. Django templates were considered but do not provide the same 
reactivity or component reusability required for a dashboard-style interface.

The way I will be coding with react is going to be by initially using AI to generate extremely atomic components from specific libraries like shadcn
for reusability and then building on top based on requirements. I usually wrap components to prevent breaking changes in my code but seeing as it is
a low scale project, using unwrapped third party components is acceptable.

## 3. Project Structure

I created a Django project called `config` and a Django app called `subscriptions`. The `subscriptions` app is responsible for:
- The `Subscription` model (database schema of a subscription)
- The API endpoints for CRUD operations
- The analytics / stats endpoint

I decided to keep things in a single app to keep the structure straightforward for an entry-level project.
